#include "spi_hard.h"
#include "ioSTC8.h"

/***********SPI功能脚映射选择***********/

#define  SPI_FUNCTION_00   0x00   //SS P12  MOSI P13  MISO P14  SCLK P15

#define  SPI_FUNCTION_01   0x04   //SS P22  MOSI P23  MISO P24  SCLK P25

#define  SPI_FUNCTION_10   0x80   //SS P74  MOSI P75  MISO P76  SCLK P77

#define  SPI_FUNCTION_11   0x0c   //SS P35  MOSI P34  MISO P33  SCLK P32
/****************************************/

/***************本驱动程序为硬件SPI驱动**********************
特点：
1、SPI数据顺序：MSB(先发送/接收数据的高位)
2、时钟控制方式：同步传输
3、时钟频率约为24/4Mhz
4、支持SPI模式：CPOL（时钟极性）= 1，CPHA（时钟相位）= 1;
   即：空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是
   SCLK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送
  是在下降沿。
5、空闲态:SCL为高电平、CS为高电平
*************************************************************/

/**************************************************************************************************
 *@函数            hard_spi_init
 *
 *@简述            初始化硬件SPI
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_spi_init(void)
{
  P_SW1 |= SPI_FUNCTION_01;//SPI功能脚选择
  
  SSIG = 1;//忽略SS引脚功能，使用MSTR确定器件是主机还是从机
  DORD = 0;//MSB顺序
  MSTR = 1;//由于SSIG=1，故MSTR = 1
  CPOL = 1;//SCL空闲为高电平
  CPHA = 1;//数据在SCL的前时钟沿驱动，后时钟沿采样

  SPIF = 1;//清零SPI中断标志位
  WCOL = 1;//清零SPI写冲突标志位
  
  set_hard_spi_speed(0x00); //SPI时钟频率为主时钟/4
  hard_spi_open(); 
}
/**************************************************************************************************
 *@函数            set_hard_spi_speed
 *
 *@简述            设置硬件SPI时钟
 *
 *@输入参数       speed - 0x00：4分频，0x01：8分频，0x02：16分频，0x03：32分频
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void set_hard_spi_speed(uint8 speed)
{
    SPCTL &= 0xfc;
    SPCTL |= (speed & 0x03);
}
/**************************************************************************************************
 *@函数            hard_spi_open
 *
 *@简述            打开SPI外设开关
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_spi_open(void)
{
   SPEN = 1;//使能SPI功能
}
/**************************************************************************************************
 *@函数            hard_spi_close
 *
 *@简述            关闭SPI外设开关
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_spi_close(void)
{
   SPEN = 0;//失能SPI功能
}
/**************************************************************************************************
 *@函数            hard_spi_transaction_byte
 *
 *@简述            硬件SPI传输一个字节函数
 *
 *@输入参数  
 *
 *@参数            data - SPI发送的数据
 *
 *输出参数
 *
 *无
 * 
 *@返回     SPI接收的数据数据
 **************************************************************************************************
 */
static uint8 hard_spi_transaction_byte(uint8 data)
{
  SPDAT = data;//加载数据，同时也启动硬件SPI的传输 
  while((SPSTAT&0x80)==0); //等待写入完成
  SPSTAT = 0xc0;           //清除中断标志，和写冲突标志，注意是对应位写1才能清零
  return SPDAT;//写入完成的同时，数据采集也完成
}
/**************************************************************************************************
 *@函数            hard_spi_transaction
 *
 *@简述            硬件SPI数据传输
 *
 *@输入参数  
 *
 *@参数            *tx - 发送数据指针
 *                 tx_len - 发送数据长度
 *                 *rx - 接收数据指针
 *                 rx_len - 接收数据长度
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_spi_transaction(const uint8 *tx, uint32 tx_len, uint8 *rx, uint32 rx_len)
{
  if(rx_len != 0)
  {
        //半双工模式（接收）
    for(uint32 i = 0; i < rx_len; i++)
    {
      rx[i] = hard_spi_transaction_byte(0xff);
    }
  }
  if(tx_len != 0)
  {
    //半双工模式（发送）
    for(uint32 i = 0; i < tx_len; i++)
    {
       hard_spi_transaction_byte(tx[i]);
    }
  }
}
