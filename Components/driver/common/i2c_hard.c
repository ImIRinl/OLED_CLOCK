#include "i2c_hard.h"
#include "ioSTC8.h"

/*******************************I2C功能脚映射选择*****************************************/

#define  I2C_FUNCTION_00   0x80   //P_SW2 bit7:1 SCL P15  SDA P14  

#define  I2C_FUNCTION_01   0x90   //P_SW2 bit7:1 SCL P25  SDA P24  

#define  I2C_FUNCTION_10   0xA0   //P_SW2 bit7:1 SCL P77  SDA P76  

#define  I2C_FUNCTION_11   0xB0   //P_SW2 bit7:1 SCL P32  SDA P33  
/*******************************I2C SCL脚*****************************************/
#define  HARD_SCL   P1_5
/**********************************注意!!!!*******************************************
*由于STC8的硬件I2C相关寄存器在片外RAM空间，访问需要先将P_SW2的BIT7设置为1,才可正常读写
即：先执行P_SW2 |= 0x80这条语句，再访问硬件I2C相关寄存器。I2C功能引脚映射已经包含P_SW2
的bit7置1，比如直接用P_SW2 |= I2C_FUNCTION_00，配置SCL P15  SDA P14
**************************************************************************************/

/**************************************************************************************************
 *@函数            hard_i2c_ulock
 *
 *@简述            硬件I2C死锁解锁
 *
 *@输入参数  
 *
 *@参数            无
 *                 
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_i2c_ulock(void)	
{
   hard_i2c_close();//关闭IIC功能
   for(uint8 i = 0; i < 9; i++)
   {
     HARD_SCL =  ~HARD_SCL;
     hard_i2c_delay();
   }
   hard_i2c_open();//打开IIC功能
}
/**************************************************************************************************
 *@函数            hard_i2c_init
 *
 *@简述            初始化硬件i2c
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 * 
 *说明:硬件I2C可能由于不稳定情况导致从机一直拉低SDA（SDA死锁），解除死锁的方式是主机在SCL产生9个时钟信号
      每次硬件IIC初始化都做解除死锁，可以确保和从机的正常通信
 **************************************************************************************************
 */
void hard_i2c_init(void)
{
  P_SW2 = I2C_FUNCTION_11;//SCL P32  SDA P33
  I2CCFG = 0xde;//配置I2C为主机模式，使能I2C功能，I2C速度为24Mhz/61 = 393Khz
  I2CMSST = 0x00;
  hard_i2c_ulock();//IIC死锁解除
  hard_i2c_open();//打开硬件IIC外设
}

/**************************************************************************************************
 *@函数            hard_i2c_open
 *
 *@简述            打开硬件I2C功能
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_i2c_open(void)
{
  I2CCFG |= 0x80;//允许硬件I2C功能
}
/**************************************************************************************************
 *@函数            hard_i2c_close
 *
 *@简述            关闭硬件I2C功能
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
void hard_i2c_close(void)
{
  I2CCFG &= ~0x80;//禁止硬件I2C功能
}
/**************************************************************************************************
 *@函数            hard_i2c_start
 *
 *@简述            硬件I2C起始信号
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
static void hard_i2c_start(void)
{
  I2CMSCR = 0x01;//起始指令
  hard_i2c_wait();//等待指令完成
}
/**************************************************************************************************
 *@函数            hard_i2c_stop
 *
 *@简述            硬件I2C停止信号
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
static void hard_i2c_stop(void)
{
  I2CMSCR = 0x06;//停止指令
  hard_i2c_wait();//等待指令完成
}
/**************************************************************************************************
 *@函数            hard_i2c_wait
 *
 *@简述            等待指令完成
 *
 *@输入参数  
 *
 *@参数            无
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
static void hard_i2c_wait(void)
{
  uint16 times = 400;
 while ((!(I2CMSST & 0x40)) && --times > 0);
    I2CMSST &= ~0x40;
}

/**************************************************************************************************
 *@函数            hard_i2c_write_byte
 *
 *@简述            硬件I2C发送一个字节
 *
 *@输入参数  
 *
 *@参数            slave_addr - 从机地址
 *                 *data - 发送数据指针
 *                 len - 发送数据长度
 *
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
static uint8 hard_i2c_write_byte(uint8 data)
{
  I2CTXD = data;//数据加载到I2CTXD中
  I2CMSCR = 0x0a;
  hard_i2c_wait();//等待指令完成
   if((I2CMSST & 0x02) != 0)//判断从机是否回应
      return 1;
   return 0;
}
/**************************************************************************************************
 *@函数            hard_i2c_read_byte
 *
 *@简述            硬件I2C接收一个字节
 *
 *@输入参数  
 *
 *@参数            ack - 主机应答
 *
 *输出参数
 *
 *无
 * 
 *@返回     接收数据
 **************************************************************************************************
 */
static uint8 hard_i2c_read_byte(uint8 ack)
{  
   if(!ack)//主机主动应答
     I2CMSCR = 0x0b; //加载主机回应数据
   else
     I2CMSCR = 0x0c;//加载主机不回应数据
   hard_i2c_wait();//等待指令完成
   return I2CRXD;
}
/**************************************************************************************************
 *@函数            hard_i2c_transaction
 *
 *@简述            硬件I2C数据传输
 *
 *@输入参数  
 *
 *@参数            slave_addr - 从机地址(7bits)
 *                 *tx - 发送数据指针
 *                 tx_len - 发送数据长度
 *                 *rx - 接收数据指针
 *                 rx_len - 接收数据长度
 *
 *输出参数
 *
 *无
 * 
 *@返回     0：通信成功 1：通信失败
 **************************************************************************************************
 */
uint8 hard_i2c_transaction(uint8 slave_addr, uint8* tx, uint32 tx_len, uint8* rx, uint32 rx_len)
{
   hard_i2c_start();//起始信号
   if(hard_i2c_write_byte(slave_addr))//I2C写模式
       return 1;
  if(tx_len != 0)//判断发送数据个数是否为0
  {
    for(uint32 i = 0; i < tx_len; i++)
    {
      if(hard_i2c_write_byte(tx[i]))
        return 1;
    }
  }
 // hard_i2c_stop();//停止信号
 // hard_i2c_start();//起始信号
  hard_i2c_stop();//停止信号
  if(rx_len != 0)//判断接收数据个数是否为0
  {
    hard_i2c_start();//起始信号
    if(hard_i2c_write_byte(slave_addr | 0x01))//I2C读模式
       return 1;

    for(uint32 i = 0; i < rx_len; i++)
    {   
      if( i < rx_len - 1)
      {
        rx[i] = hard_i2c_read_byte(0);//主机应答，请求下一组数据
      }
      else//最后一组数据
      {
        rx[i] = hard_i2c_read_byte(1);//主机不应答，不请求下一组数据
      }
    }
  }
   hard_i2c_stop();//停止信号
  return 0;//返回成功
}
/**************************************************************************************************
 *@函数            i2c_delay
 *
 *@简述            硬件I2C时钟延时
 *
 *@输入参数  
 *
 *@参数            无
 *                 
 *输出参数
 *
 *无
 * 
 *@返回     无
 **************************************************************************************************
 */
#pragma optimize=none  //防止IAR优化，避免延时不正常
static void hard_i2c_delay(void)	
{
   volatile uint8  i = 7;//加volatile，防止IAR优化，避免延时不正常
   while (--i);
}